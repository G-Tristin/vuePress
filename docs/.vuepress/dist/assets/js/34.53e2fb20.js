(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{184:function(e,t,a){"use strict";a.r(t);var n=a(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"koa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#koa","aria-hidden":"true"}},[e._v("#")]),e._v(" koa")]),e._v(" "),a("p",[e._v("koa是一个node框架用于构建一个本地的node服务器")]),e._v(" "),a("h2",{attrs:{id:"使用koa创建服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用koa创建服务器","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用koa创建服务器")]),e._v(" "),a("ul",[a("li",[e._v("引入一个koa模块")]),e._v(" "),a("li",[e._v("创建一个koa实例对象")]),e._v(" "),a("li",[e._v("使用koa中间件")]),e._v(" "),a("li",[e._v("监听端口")])]),e._v(" "),a("p",[e._v("示例代码:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const Koa = require('koa');\nconst app = new Koa();\napp.use((ctx,next)=>{\n  await next();\n  ctx.response.type = 'text/html',\n  ctx.response.body = '<h1>hello world!<h1>\n})\napp.listen(8080)\n")])])]),a("h2",{attrs:{id:"koa-middleware"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#koa-middleware","aria-hidden":"true"}},[e._v("#")]),e._v(" koa middleWare")]),e._v(" "),a("p",[e._v("使用app.use()使用中间件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("app.use(async (ctx,next)=>{\n  await next() // 会等待下一个中间件执行之后再执行下面的代码 所以我们执行异步函数的时候需要注意代码的执行顺序\n  ctx.response.type='txt/html'\n  ctx.response.body= '<h1> hello world </h1>'\n})\n")])])]),a("p",[e._v("每接收到一个http请求,koa就会通过app.use()注册的async函数,并传入ctx和next参数")]),e._v(" "),a("h2",{attrs:{id:"koa的执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#koa的执行顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" koa的执行顺序")]),e._v(" "),a("p",[e._v("如果app.use()当中的回调函数是一个异步函数(async)那么如果我们使用了await next(),那么回到函数当中的其他代码就要等到下一个app.use()中的函数执行完成之后再执行")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const Koa = require('koa')\nconst app = new Koa();\nfunction log(){\n  return new Promise((res,rej)=>{\n    setTimeout(function(){\n      console.log('a')\n    },200)\n  })\n}\napp.use(async (ctx, next) => {\n  console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL\n  await next(); // 调用下一个middleware\n});\n\napp.use(async (ctx, next) => {\n  const start = new Date().getTime(); // 当前时间\n  await next(); // 调用下一个middleware\n  const ms = new Date().getTime() - start; // 耗费时间\n  console.log(`Time: ${ms}ms`); // 打印耗费时间\n});\n\napp.use(async (ctx, next) => {\n  await next();\n  console.log('我出现在Time之前')\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\napp.listen(8000)\nconsole.log('开启服务器')\n")])])]),a("h2",{attrs:{id:"koa原理讲解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#koa原理讲解","aria-hidden":"true"}},[e._v("#")]),e._v(" koa原理讲解")]),e._v(" "),a("p",[e._v("1.koa的中间件机制:")]),e._v(" "),a("p",[e._v("koa中间件的机制就是函数组合的概念，将一组需要顺序执行的函数复合为一个函数，外层函数的实际参数时内层函数的返回值。这种机制就是KOA源码的难点和精髓。")]),e._v(" "),a("p",[e._v("2.context")]),e._v(" "),a("p",[e._v("koa为了能够简化API，引入了上下文的概念，将原始请求对象req和响应对象res封装并挂载到context上，并且在context上设置了getter和setter，从而简化操作。")]),e._v(" "),a("p",[e._v("浏览器会默认发送ico请求以获取浏览器图标 所以我们需要对这一部分进行处理")])])}],!1,null,null,null);t.default=s.exports}}]);
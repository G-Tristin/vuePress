(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{171:function(e,n,t){"use strict";t.r(n);var o=t(0),a=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"declare-module-模块插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#declare-module-模块插件","aria-hidden":"true"}},[e._v("#")]),e._v(" declare module -- 模块插件")]),e._v(" "),t("p",[e._v("有时通过import导入一个模块插件，可以改变另一个原有模块的结构。此时如果\n原有模块已经有了类型申明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。TS提供了一个语法 declare module，它可以用来扩展原有模块的类型。")]),e._v(" "),t("p",[e._v("如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用declare module扩展原有模块")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// types/moment/ment-plugin/index.d.ts\nimport * as moment from 'moment'\ndeclare module 'moment'{\n  export function foo():moment.CalendarKey\n}\n\n// src/index.ts\nimport * as moment from 'moment';\nimport 'moment-plugin';\nmoment.foo\n")])])]),t("p",[e._v("declare module 也可用于在一个文件中一次性声明多个模块的类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//types/foo-bar.d.ts\ndeclare module 'foo'{\n  export interface Foo{\n    foo:string\n  }\n}\n\ndeclare module 'bar'{\n  export function bar():string\n}\n\n// src/index.ts\nimport {Foo} from 'foo'\nimport * as bar from 'bar'\nlet f:Foo\nbar.bar()\n")])])])])}],!1,null,null,null);n.default=a.exports}}]);
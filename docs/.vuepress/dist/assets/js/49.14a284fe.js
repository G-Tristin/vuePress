(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{169:function(e,n,a){"use strict";a.r(n);var t=a(0),s=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"declare-namespace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#declare-namespace","aria-hidden":"true"}},[e._v("#")]),e._v(" declare namespace")]),e._v(" "),a("p",[e._v("namespace 是ts早期时为了解决模块化而创造的关键字又称为命名空间，namespace被淘汰了，但是在申明文件中，declare namespace还是比较常用的，它\n用来表示全局变量是一个对象，包含很多子属性。")]),e._v(" "),a("p",[e._v("如果对象拥有深层的层级，则需要用嵌套的namespacel来声明深层的属性的类型")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// src/jQuery.d.ts\ndeclare namespace jQuery{\n    function ajax(url:string,setting?:any):void;\n    namespace fn{\n        function extend(objcet:any):viod;\n    };\n}\n\njQuery.ajax('/api/ger_something');\njQuery.fn.extend({\n    chenck:function(){\n        return this.each(function(){\n            this.check = true\n        })\n    }\n})\n")])])]),a("p",[e._v("假如jQuery下仅有fn这一个属性(没有ajax等其它属性和方法)，则可以不需要嵌套namespace")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("declare namespace jQuery.fn{\n    function extend(object.any):void\n}\n\njQuery.fn.extend({\n    check:function(){\n        return this.each(function(){\n            this.checked = true\n        })\n    }\n})\n")])])]),a("p",[e._v("除了全局变量之外，可能有一些类型我们也希望能够暴露出来。在类型声明文件当中，我们可以直接使用interface或者type来申明一个全局的接口或者类型。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface AjaxSettigs{\n    methods?:'GET'|'POST'\n    data?:any\n}\n以上是申明了一个全局的类型\n\ndeclare namesapce jQuery{\n    function ajax(url:sting,settings?AjaxSettigs):void\n}\n以上是申明了一个全局变量\n")])])])])}],!1,null,null,null);n.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{206:function(t,s,e){"use strict";e.r(s);var n=e(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"class-继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class-继承","aria-hidden":"true"}},[t._v("#")]),t._v(" class 继承")]),t._v(" "),e("p",[t._v("Class 可以通过extends关键字实现继承")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Point {\n    ...\n}\n\nclass ColorPoint extends Point{\n    constructor(x,y,color){\n        super(x,y) //调用父类的constructor方法\n        this.color = color //子类自己的属性\n    }\n    toString(){\n        return this.color + '' + super.toString() //调用父类的toString()方法\n    }\n}\n")])])]),e("h2",{attrs:{id:"super"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super","aria-hidden":"true"}},[t._v("#")]),t._v(" super")]),t._v(" "),e("p",[t._v("在类的继承当中super关键字代表着父类的构造函数,用来新建父类的this对象")]),t._v(" "),e("p",[t._v("子类必须在constructor方法中调用super方法,否则新建私立时会报错,因为子类自己的this对象,必须先通过父类的构造函数\n完成塑造,得到与父类同样的实例属性和方法,然后对其进行加工,加上子类自己的实例属性和方法.如果不调用super方法,子类就得不到this对象.")]),t._v(" "),e("p",[t._v("原理:")]),t._v(" "),e("p",[t._v("ES5的继承,实质上是先制造子类的实例对象this,然后再将父类的方法添加到this上面(Parent.apply(this)).ES6的继承机制完全相同,实质是先将父类实例对象的属性和方法,加到this上面(所以必选先调用super方法),然后再用子类的构造函数去修改this.")]),t._v(" "),e("p",[t._v("如果子类没有定义constructor方法,这个方法会被默认添加,代码如下.也就是说,不管有没有显示定义,任何一个子类都有constructor方法.并且在里面调用了super")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class ColorPoint extends Point{\n}\n//等同于\nclass ColorPoint extends Point{\n    constructor(..args){\n        super(...args)\n    }\n}\n")])])]),e("p",[t._v("note:")]),t._v(" "),e("p",[t._v("在子类的构造函数当中,只有调用super之后,才可以使用this关键字,否则会报错.这是因为子类实例的构建,基于父类实例,只有super方法才能调用父类实例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Point{\n    constructor(x,y){\n        this.x = x\n        this.y = y\n    }\n}\n\nclass ColorPoint extends Point{\n    constructor(x,y,color){\n        this.color = color;//error\n        super(x,y);\n        this.color = color//正确 必须先调用super然后使用this\n    }\n}\n")])])]),e("h2",{attrs:{id:"静态方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 静态方法")]),t._v(" "),e("p",[t._v("父类的静态方法也会被子类继承 这个与ES5是不同的")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A{\n    static hello(){\n        console.log('hello world')\n    }\n}\n\nclass B extends Class A {\n}\nB.hello //'hello world'\n")])])]),e("h2",{attrs:{id:"判断子类是否继承自另一个类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断子类是否继承自另一个类","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断子类是否继承自另一个类")]),t._v(" "),e("p",[t._v("Object.getPrototypeOf() 该方法可以获取到子类的父类\nObject.getPrototypeOf(ColorPoint) // Point")]),t._v(" "),e("h2",{attrs:{id:"super详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super详解","aria-hidden":"true"}},[t._v("#")]),t._v(" super详解")]),t._v(" "),e("p",[t._v("super关键字存在着两种用法,既可以当函数使用也可以当对象使用.在这两种情况下,它的用法完全不同")]),t._v(" "),e("ul",[e("li",[t._v("第一种")])]),t._v(" "),e("p",[t._v("super作为函数调用时,代表父类的构造函数.ES6要求,子类的构造函数必须执行一次super函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A {}\nclass B extends class A{\n    constructor(){\n        super();\n    }\n}\n")])])]),e("p",[t._v("note:super虽然代表类父类A的构造函数,但是返回的是子类B的实例,即super内部的this指的是B,因此super()在这里相当于\nA.prototype.constructor.call(this)")]),t._v(" "),e("ul",[e("li",[t._v("第二种")])]),t._v(" "),e("p",[t._v("super作为对象时,在普通方法中,指向父类的原型对象;在静态方法中,指向父类")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A{\n    p(){\n        return 2\n    }\n}\n\nclass B extends class A {\n    constructor(){\n        super()\n        consolo.log(super.p()) //此时super指向A.prototype 所以\n    }\n}\n")])])]),e("p",[t._v("注意定义在父类实例上的方法无法访问,因为super代表的是原型 所以实例上的方法无法访问 如下")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n")])])]),e("p",[t._v("如果super作为对象,用在静态方法当中,这是super指向父类,而不是父类的原型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Point{\n    static myMethods(esg){\n        console.log('static',esg)\n    }\n    myMthods(msg){\n        console.log('instance',msg)\n    }\n}\n\nclass Child extends Parent {\n    static myMethod(msg){\n        super.myMthod(msg)\n    }\n    myMethod(msg){\n        super.myMythod(msg)\n    }\n}\nChild.myMethod(1)//static 1\nconst child = new Child()\nchild.myMthod(2)//instance 2\n")])])]),e("p",[t._v("在上面代码中在普通方法中super指向父类的原型,在静态方法中指向父类")]),t._v(" "),e("h3",{attrs:{id:"最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。","aria-hidden":"true"}},[t._v("#")]),t._v(" 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var obj = {\n  toString() {\n    return "MyObject: " + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n')])])]),e("h2",{attrs:{id:"mixin-模式的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin-模式的实现","aria-hidden":"true"}},[t._v("#")]),t._v(" Mixin 模式的实现")]),t._v(" "),e("p",[t._v("Mixin 指的是多个对象合成一个新的对象,新对象具有各个组成成员的接口.它的最简单实现如下")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const a ={\n    a:'a'\n}\nconst b ={\n    b:'b'\n}\nconst c ={...a,...b}\n")])])]),e("p",[t._v("下面是一个更加完备的实现")]),t._v(" "),e("p",[t._v("function mix(...mixins){\nclass Mix{}\nfor(let mixin of minxins){\ncopyProperties(Mix.prototype,mixin)\ncopyProperties(Mix.prototype,Reflect.getPrototypeOf(minxin))\n}\nreturn Mix\n}")]),t._v(" "),e("p",[t._v('function copyProperties(target, source) {\nfor (let key of Reflect.ownKeys(source)) {\nif ( key !== "constructor"\n&& key !== "prototype"\n&& key !== "name"\n) {\nlet desc = Object.getOwnPropertyDescriptor(source, key);\nObject.defineProperty(target, key, desc);\n}\n}\n}')]),t._v(" "),e("p",[t._v("上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class DistributedEdit extends mix(Loggable, Serializable) {\n  // ...\n}\n")])])])])}],!1,null,null,null);s.default=r.exports}}]);
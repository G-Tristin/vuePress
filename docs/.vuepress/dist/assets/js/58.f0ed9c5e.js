(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{195:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"路由小技巧"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由小技巧","aria-hidden":"true"}},[e._v("#")]),e._v(" 路由小技巧")]),e._v(" "),n("p",[e._v("在Vue项目当中在不同路由使用同一个组件的情况在实际业务中使用的频率还是非常多的")]),e._v(" "),n("p",[e._v("但是在默认的情况下，这2个页面之间的切换时不会触发vue的create或者mounted的钩子的，官方文档说通过watch $router的变化来做处理，但是其实说的还是比较麻烦的。简便的操作是在router-view上加上唯一的一个key，来保证路由切换的时候都会重新渲染和触发钩子。这样就会比较简单。")]),e._v(" "),n("p",[e._v("实际原理：vue的渲染机制每次碰到组件的key值不同时都会重新渲染该组件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<router-view :key="key"></router-view>\n\ncomputed:{\n  key(){\n    return this.$router.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()\n  }\n}\n')])])])])}],!1,null,null,null);t.default=a.exports}}]);
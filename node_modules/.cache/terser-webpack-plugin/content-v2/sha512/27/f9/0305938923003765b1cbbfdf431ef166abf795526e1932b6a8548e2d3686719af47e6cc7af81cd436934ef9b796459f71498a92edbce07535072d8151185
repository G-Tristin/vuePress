{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{177:function(e,a,r){\"use strict\";r.r(a);var t=r(0),s=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,r=e._self._c||a;return r(\"div\",{staticClass:\"content\"},[r(\"h1\",{attrs:{id:\"stream-流\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stream-流\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" stream - 流\")]),e._v(\" \"),r(\"p\",[e._v(\"流(stream)是 Node.js 中处理流式数据的抽象接口。 所有的流都是 EventEmitter 的实例。也就是可以\"),r(\"strong\",[e._v(\"调用EventEmitter的API\")]),e._v(\"。\")]),e._v(\" \"),r(\"p\",[e._v(\"流的基本类型\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"可写流\")]),e._v(\" \"),r(\"li\",[e._v(\"可读流\")]),e._v(\" \"),r(\"li\",[e._v(\"可读可写的流\")]),e._v(\" \"),r(\"li\",[e._v(\"在读写过程中可以修改或者转换数据的流\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"缓冲\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缓冲\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 缓冲\")]),e._v(\" \"),r(\"p\",[e._v(\"可写流和可读流都会在内部的缓冲器中存储数据，可以分别使用writeable.writeableBuffer或readable.readableBuffer来获取。\")]),e._v(\" \"),r(\"p\",[e._v(\"可缓冲的数据大小取决于传入流\"),r(\"strong\",[e._v(\"构造函数\")]),e._v(\"的highWaterMark选项。对于普通的流，highWaterMark指定了字节总数。对于对象模式的流，highWaterMark指定了对象的总数。\")]),e._v(\" \"),r(\"p\",[e._v(\"当调用stream.push(chunk)时，数据会被缓冲到可读流当中。如果流的消费者没有调用stream.read()，则数据会保留在内部队列直到被消费。\")]),e._v(\" \"),r(\"p\",[e._v(\"一旦内部的可读缓冲的总大小达到highWaterMark指定的阈值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费(也就是说，流会停止调用内部的用于填充可读缓冲的readable._read())\")]),e._v(\" \"),r(\"p\",[e._v(\"当调用writeable.write(chunk)时，数据会被缓冲在可写流当中。当内部的可写缓冲的总大小小于highWaterMark设置的阈值时，调用writeable.write()会返回true。一旦\\n内部的缓冲大小达到或者超过highWaterMark时，会返回false。\")]),e._v(\" \"),r(\"p\",[e._v(\"stream API的主要目的，特别是stream.pipe(),是为了限制数据的缓冲到可接受的程度，也就是读写速度不一致的源头与目的地不会压垮内存\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"流的运作\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#流的运作\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 流的运作\")]),e._v(\" \"),r(\"p\",[e._v(\"可写流会暴露了一些方法，比如 write() 和 end() 用于写入数据到流。\\n而当数据可以从流读取时，可读流会使用EventEmitter API来通知应用程序。\\n对于只需写入数据到流或从流消费数据的应用程序，并不需要直接实现流的接口，通常也不需要调用 require('stream')\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"可写流\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可写流\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 可写流\")]),e._v(\" \"),r(\"p\",[e._v(\"可写流时是对数据要被写入的目的地的一种抽象\")]),e._v(\" \"),r(\"p\",[e._v(\"可写流的例子包括:\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"客户端的http请求\")]),e._v(\" \"),r(\"li\",[e._v(\"服务端的http响应\")]),e._v(\" \"),r(\"li\",[e._v(\"fs的写入流\")]),e._v(\" \"),r(\"li\",[e._v(\"zlib流\")]),e._v(\" \"),r(\"li\",[e._v(\"crypto流\")]),e._v(\" \"),r(\"li\",[e._v(\"TCP socket流\")]),e._v(\" \"),r(\"li\",[e._v(\"子进程 stdin\")]),e._v(\" \"),r(\"li\",[e._v(\"process.stdout、process.stderr\")])]),e._v(\" \"),r(\"p\",[e._v(\"所有可写流都实现了 stream.Writable 类定义的接口。\")]),e._v(\" \"),r(\"p\",[e._v(\"尽管可写流的具体实例可能略有差别，但所有的可写流都遵循同一基本的使用模式，如以下例子所示:\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"// 获取可读流的某种方式\\nconst myStream = getWritableStreamSomehow();\\nmyStream.write('一些数据');\\nmyStream.write('更多数据');\\nmyStream.end('完成写入数据');\\n\")])])]),r(\"h2\",{attrs:{id:\"简述node当中事件与方法的区别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#简述node当中事件与方法的区别\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 简述node当中事件与方法的区别\")]),e._v(\" \"),r(\"p\",[e._v(\"在node当中类的事件就是可以使用\"),r(\"em\",[e._v(\"EventEmitter\")]),e._v(\"类的使用方式给实例添加事件形如\"),r(\"code\",[e._v(\"reader.on('close',()=>{...})\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"close-事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#close-事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'close'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"当流或者其底层资源被关闭时触发。表明不会再触发其它事件，也不再发生操作。但不是所有的可写流都会触发该事件。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"error-事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#error-事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'error'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"当写入数据错误时触发，当触发error事件时，流还没有被关闭。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"finish-事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#finish-事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'finish'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"调用stream.end()切缓冲数据都已经传给底层系统后触发\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const writer = getWritableStreamSomehow(); // 泛指获取可写流的一种方式\\nfor (let i = 0; i < 100; i++) {\\n  writer.write(`写入 #${i}!\\\\n`);\\n}\\nwriter.end('写入结尾\\\\n');\\nwriter.on('finish', () => {\\n  console.error('写入已完成');\\n});\\n\")])])]),r(\"h3\",{attrs:{id:\"pipe事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pipe事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" pipe事件\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"src:通过管道流入到可写流的来源流。\\n当在可读流上调用stream.pipe()时触发。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const writer = getWritableStreamSomehow();\\nconst reader = getReadableStreamSomehow();\\nwriter.on('pipe', (src) => {\\n  console.error('有数据正通过管道流入写入器');\\n  assert.equal(src, reader);\\n});\\nreader.pipe(writer);\\n\")])])]),r(\"h3\",{attrs:{id:\"writable-cork方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#writable-cork方法\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" writable.cork方法\")]),e._v(\" \"),r(\"p\",[e._v(\"强制把所有写入的数据都缓存到内存中。当调用stream.uncork()或者\"),r(\"code\",[e._v(\"stream.end() == writable.end()\")]),e._v(\" 时，数据才会被输出。\")]),e._v(\" \"),r(\"p\",[e._v(\"eg:\")]),e._v(\" \"),r(\"p\",[e._v(\"stream一般指流的统称，这里的stream.end()中stream指的可能是可写流，也可能是可写可读流或转换流。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"writable-end方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#writable-end方法\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" writable.end方法\")]),e._v(\" \"),r(\"p\",[e._v(\"调用 writable.end() 表明已没有数据要被写入可写流。 可选的 chunk 和 encoding 参数可以在关闭流之前再写入一块数据。 如果传入了 callback 函数，则会做为监听器添加到 'finish' 事件。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"writable-write\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#writable-write\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" writable.write()\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"chunk 要写入的数据\")]),e._v(\" \"),r(\"li\",[e._v(\"encoding 如果chunk是字符串，则指定字符编码\")]),e._v(\" \"),r(\"li\",[e._v(\"callback 当数据块被输出到目标后的回调函数\\nreturn  Boolean\")])]),e._v(\" \"),r(\"p\",[e._v(\"writable.write() 写入数据到流，并在数据被完全处理之后调用 callback。 如果发生错误，则 callback 可能被调用也可能不被调用。 为了可靠地检测错误，可以为 'error' 事件添加监听器。\")]),e._v(\" \"),r(\"p\",[e._v(\"在接收了chunk后，如果内部的缓冲小于创建流时配置的highWaterMark，则返回 true。如果返回false,则应该停止向流写入数据，直到'drain'事件被触发。\")]),e._v(\" \"),r(\"p\",[e._v(\"当流还未被排空时，调用write()会缓冲chunk，并返回false。一旦所有当前缓冲的数据块都被排空了(被操作系统接收并传输)，则触发'drain'事件。建议一旦write()返回false，则不再写入任何数据块，直到'drain'事件被触发。当流还未被排空时，也是可以调用write()，Node.js会缓冲所有被写入的数据块，直到达到最大内存占用，这时它会无条件中止。甚至在它中止之前，高内存占用将会导致垃圾回收器的性能变差和RSS变高（即使内存不再需要，通常也不会被释放回系统）。如果远程的另一端没有读取数据，TCP 的 socket可能永远也不会排空，所以写入到一个不会排空的socket可能会导致远程可利用的漏洞。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"drain-事件-重要\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#drain-事件-重要\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'drain'事件 --- 重要\")]),e._v(\" \"),r(\"p\",[e._v(\"drain(流干)事件将配合stream.write使用。\")]),e._v(\" \"),r(\"p\",[e._v(\"drain事件的触发条件是，当缓存区有需要写入的数据并且当缓存区被清空时会触发drain事件。\")]),e._v(\" \"),r(\"p\",[e._v(\"如果调用stream.write(chunk)返回false，则当可以继续写入数据到流时会触发'drain'事件。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"简述writable-write-方法与writable的drain事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#简述writable-write-方法与writable的drain事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 简述writable.write()方法与writable的drain事件\")]),e._v(\" \"),r(\"p\",[e._v(\"writable.write()方法的返回值分为true或者false,当流的内部缓冲小于创建流时配置的highWaterMark时，它才会返true。当流的内部缓冲超过或者等于阈值时就会返回false，此时流\\n依旧可以将缓冲区的数据写入到目标当中，但是我们应该主动的停止将数据写入到流，直到缓冲当中的数据被消耗，此时会触发drain事件，之后我们才可以再次往流当中写入数据。\")]),e._v(\" \"),r(\"p\",[e._v(\"eg:\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"// 向可写流中写入数据一百万次。\\n// 留意背压（back-pressure）。\\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\\n  let i = 1000000;\\n  write();\\n  function write() {\\n    let ok = true;\\n    do {\\n      i--;\\n      if (i === 0) {\\n        // 最后一次写入。\\n        writer.write(data, encoding, callback);\\n      } else {\\n        // 检查是否可以继续写入。 \\n        // 不要传入回调，因为写入还没有结束。\\n        ok = writer.write(data, encoding);\\n      }\\n    } while (i > 0 && ok);\\n    if (i > 0) {\\n      // 被提前中止。\\n      // 中止的原因是writer.write返回值为false --就是当流的缓冲区数据达到阈值时的返回值\\n      // 此时流还是会给目标当中写入数据data，但是node的stream模块建议我们不再将数据写入到流的缓冲区\\n      // 直到流的缓冲区的数据被消耗完，此时触发drain事件，这时我们可以再次往流当中写入数据\\n      //而所有的流都是EventEmitter实例，所以我们可以通过once方法给流添加一次性事件'drain'\\n      writer.once('drain', write); \\n      // 流触发了drain事件 说明流的缓冲区已经没有数据了，此时我们可以往流当中继续写入数据。\\n    }\\n  }\\n}\\n\")])])]),r(\"p\",[e._v(\"注意：writable下的方法和事件都是针对流的，而流内部会把数据写入到对应的目标当中，比如我们创建一个fs的可写流，所有的流下的事件和方法都是针对这个流的。\\n并且此时我们操作的数据都是写入到流当中的数据，最后流会把数据写入到目标文件中。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"可读流\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可读流\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 可读流\")]),e._v(\" \"),r(\"p\",[e._v(\"可读流是对提供数据来源的一种抽象\")]),e._v(\" \"),r(\"p\",[e._v(\"可读流的例子包括:\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"客户端的http响应\")]),e._v(\" \"),r(\"li\",[e._v(\"服务器的http响应\")]),e._v(\" \"),r(\"li\",[e._v(\"fs的读取流\")]),e._v(\" \"),r(\"li\",[e._v(\"zlib流\")]),e._v(\" \"),r(\"li\",[e._v(\"crypto流\")]),e._v(\" \"),r(\"li\",[e._v(\"TCP socket\")]),e._v(\" \"),r(\"li\",[e._v(\"子进程的stdout和stderr\")]),e._v(\" \"),r(\"li\",[e._v(\"process.stdin\\n所有可读流都实现了 stream.Readable 类定义的接口。\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"两种读取模式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#两种读取模式\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 两种读取模式\")]),e._v(\" \"),r(\"p\",[e._v(\"可读流运作于两种模式之一： 流动模式或暂停模式\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"流动模式中，数据自动从底层系统读取，并通过EventEmitter接口的事件尽可能快的被提供给应用程序。\")]),e._v(\" \"),r(\"li\",[e._v(\"在暂停模式中，必须显式调用stream.read()读取模块。\")])]),e._v(\" \"),r(\"p\",[e._v(\"所有可读流都开始于暂停模式，可以通过一下方式切换到流动模式:\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"添加'data'事件句柄\")]),e._v(\" \"),r(\"li\",[e._v(\"调用stream.resume()\")]),e._v(\" \"),r(\"li\",[e._v(\"调用stream.pipe()\\n可读流可以通过一下方式切换回暂停流\")]),e._v(\" \"),r(\"li\",[e._v(\"如果没有管道目标，则调用stream.pause()\")]),e._v(\" \"),r(\"li\",[e._v(\"如果有管道目标，则移除所有管道目标。调用stream.unpipe()可以移除多个管道目标\\n如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时，没有监听 'data' 事件或 'data' 事件句柄已移除。\")])]),e._v(\" \"),r(\"p\",[e._v(\"添加 'readable' 事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。 如果 'readable' 事件句柄被移除，且存在 'data' 事件句柄，则流会再次开始流动。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"三种状态\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三种状态\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 三种状态\")]),e._v(\" \"),r(\"p\",[e._v(\"可读流的两种模式是对发生在可读流中更加复杂的内部状态管理的一种简化的抽象。\")]),e._v(\" \"),r(\"p\",[e._v(\"在任意时刻，可读流会处于以下三种状态之一:\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"readable.readableFlowing === null\")]),e._v(\" \"),r(\"li\",[e._v(\"readable.readableFlowing === false\")]),e._v(\" \"),r(\"li\",[e._v(\"readable.readableFlowing === true\\n当 readable.readableFlowing 为 null 时，没有提供消费流数据的机制，所以流不会产生数据。 在这个状态下，监听 'data' 事件、调用 readable.pipe()、或调用 readable.resume() 都会使 readable.readableFlowing 切换到 true，可读流开始主动地产生数据并触发事件。\")])]),e._v(\" \"),r(\"p\",[e._v(\"调用 readable.pause()、 readable.unpipe()、或接收到背压，则 readable.readableFlowing 会被设为 false，暂时停止事件流动但不会停止数据的生成。 在这个状态下，为 'data' 事件绑定监听器不会使 readable.readableFlowing 切换到 true。\")]),e._v(\" \"),r(\"p\",[e._v(\"当 readable.readableFlowing 为 false 时，数据可能会堆积在流的内部缓冲中。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const { PassThrough, Writable } = require('stream');\\nconst pass = new PassThrough();\\nconst writable = new Writable();\\n\\npass.pipe(writable);\\npass.unpipe(writable);\\n// readableFlowing 现在为 false。\\n\\npass.on('data', (chunk) => { console.log(chunk.toString()); });\\npass.write('ok'); // 不会触发 'data' 事件。\\npass.resume(); // 必须调用它才会触发 'data' 事件。 data事件的触发机制是可读流从暂停模式切换到流动模式\\n\")])])]),r(\"h3\",{attrs:{id:\"使用一种接口风格\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用一种接口风格\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 使用一种接口风格\")]),e._v(\" \"),r(\"p\",[e._v(\"对于大多数用户，建议使用 readable.pipe()，因为它是消费流数据最简单的方式。 如果开发者需要精细地控制数据的传递与产生，可以使用 EventEmitter、 readable.on('readable')/readable.read() 或 readable.pause()/readable.resume()。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"close-事件-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#close-事件-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'close'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"当流或者其底层资源被关闭时触发。表明不会在触发其他事件，也不会再发生操作。\")]),e._v(\" \"),r(\"p\",[e._v(\"不是所有的可读流都会触发'close'事件\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"data-事件-这是一个事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#data-事件-这是一个事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'data'事件(这是一个事件)\")]),e._v(\" \"),r(\"p\",[r(\"em\",[e._v(\"当流将数据块传送给消费者后触发。\")])]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"chunk 数据块 对于非对象模式的流，chunk可以时字符串或者时Buffer。对于对象模式的流，chunk可以是任意的javascript的值，除了null。\")])]),e._v(\" \"),r(\"p\",[e._v(\"当调用 readable.pipe()， readable.resume() 绑定监听器到 'data' 事件时，流会转换到流动模式。 当调用 readable.read() 且有数据块返回时，也会触发 'data' 事件。\")]),e._v(\" \"),r(\"p\",[e._v(\"这里的readable指的时可读流 比如使用fs.createReadStream创建出来的流\")]),e._v(\" \"),r(\"p\",[e._v(\"如果使用 readable.setEncoding() 为流指定了默认的字符编码，则监听器回调传入的数据为字符串，否则传入的数据为 Buffer。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const readable = getReadableStreamSomehow();\\nreadable.on('data', (chunk) => {\\n  console.log(`接收到 ${chunk.length} 个字节的数据`);\\n});\\n\")])])]),r(\"h3\",{attrs:{id:\"end-事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#end-事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'end'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"当流中没有数据可供消费时触发\\n'end'事件只有再数据被完全消费的时候才会触发。要想触发该事件，可以将流切换到流动模式，或反复调用stream.read()直到数据被消费完。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const readable = getReadableStreamSomehow()\\nreadable.on('data',(chunk)=>{\\n  console.log(`接收到${chunk.length}个字节数据`)\\n})\\nreadable.on('end',()=>{\\n  console.log('没有数据了')\\n})\\n\")])])]),r(\"h3\",{attrs:{id:\"error-事件-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#error-事件-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'error'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"当流因底层内部出错而不能产生数据、或推送无效的数据块时触发\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"readable-事件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-事件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 'readable'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"当流中有数据可供读取时触发。并且readable事件有一个非常巧妙的设计就是它会自动检测暂存区是否有数据\\n如果没有数据，那么它会自动获取数据到暂存区，并且触发回调函数，我们可以在回调中通过read()方法获取数据。\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"readable读取数据是可以随机的控制速率的，不限于highWaterMark。readable可以比喻为是从水池中取水，它有添水和取水时机的问题。readable在两种情况下读取数据的情形是和data相同的，一种是rs.read()不指定size的时候，另一种是指定的size和highWaterMark相同的时候。之所以结果会相同，也与读取的规则有关。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"let fs = require('fs');\\nlet path = require('path');\\n \\nlet rs = fs.createReadStream(path.join(__dirname, '1.txt'),{\\n    highWaterMark: 3 // 设置读取流的阈值\\n});\\nrs.on('readable', function(data){\\n    console.log(rs.read());\\n})\\n\\n\")])])]),r(\"p\",[e._v(\"'readable' 事件表明流有新的动态(流的状态)：要么有新的数据，要么到达流的尽头。 对于前者，stream.read() 会返回可用的数据。 对于后者，stream.read() 会返回 null。 例如，下面的例子中， foo.txt 是一个空文件:\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const fs = require('fs');\\nconst rr = fs.createReadStream('foo.txt');\\nrr.on('readable', () => {\\n  console.log(`读取的数据: ${rr.read()}`);\\n});\\nrr.on('end', () => {\\n  console.log('结束');\\n});\\n\")])])]),r(\"p\",[e._v(\"如果同时使用 'readable' 事件和 'data' 事件，则 'readable' 事件会优先控制流，也就是说，当调用 stream.read() 时才会触发 'data' 事件。 readableFlowing 属性会变成 false。 当移除 'readable' 事件时，如果存在 'data' 事件监听器，则流会开始流动，也就是说，无需调用 .resume() 也会触发 'data' 事件。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"readable-read-size\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-read-size\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.read(size)\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"size 要读取的数据的字节数\")])]),e._v(\" \"),r(\"p\",[e._v(\"readable.read()应该只对处于暂停模式的可读流进行操作。所以一般配合readable.readable事件使用。\")]),e._v(\" \"),r(\"p\",[r(\"em\",[e._v(\"从内部缓冲拉取并返回数据\")]),e._v(\"。如果没有可读的数据则返回null,默认情况下readable.read()返回的数据对象是buffer对象，除非使用readable.setEconding()指定字符编码或者流处于对象模式。\")]),e._v(\" \"),r(\"p\",[e._v(\"如果可读的数据不超过size的字节数，则返回内部缓冲剩余的数据。(那么也就是说这个方法只能读取暂存区的数据)\")]),e._v(\" \"),r(\"p\",[e._v(\"如果流已经结束则返回null\")]),e._v(\" \"),r(\"p\",[e._v(\"如果没有指定size参数，则返回内部缓冲中的所有数据\")]),e._v(\" \"),r(\"p\",[e._v(\"readable.read()应该只对处于暂停模式的可读流进行操作。在流动模式中，readable.read会自动调用直到内部缓冲的数据被耗尽\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const readable = getReadableSreamSomehow()\\nreadable.on('readable',()=>{\\n  let chunk\\n  while(null !== (chunk = readable.read())){\\n    console.log(`接收到 ${chunk.length} 字节的数据`)\\n  }\\n})\\n\")])])]),r(\"h3\",{attrs:{id:\"readable-pause\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-pause\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.pause()\")]),e._v(\" \"),r(\"p\",[e._v(\"使流动模式的流停止触发'data'事件，并切换出流动模式。任何可用的数据都会保留再内部缓存中。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const readable = getReadableStreamSomehow()\\nreadable.on('data',(chunk)=>{\\n  console.log(`接收到${chunk.length}个字节的数据`)\\n  readable.pause()\\n  console.log('暂停一秒')\\n  setTimeout(function(){\\n    console.log('数据开始流动了')\\n    readable.resume()\\n  },1000)\\n})\\n\")])])]),r(\"h3\",{attrs:{id:\"readbale-pipe\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readbale-pipe\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readbale.pipe()\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"destination 数据写入的目标\")]),e._v(\" \"),r(\"li\",[e._v(\"options\\n\"),r(\"ul\",[r(\"li\",[e._v(\"end 当读取器结束时终止写入器。\")])])]),e._v(\" \"),r(\"li\",[e._v(\"返回目标可写流，如果时Duplex流或者是Transform流则可以形成管道链\\n绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。数据流会被自动管理，所以即使可读流更快，目标可写流也不会\\n超负荷。\")])]),e._v(\" \"),r(\"p\",[e._v(\"例子: 将可读流的所有数据通过管道推送到file.txt文件:\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const readable = getReadableStreamSomehow()\\nconst writeable = fs.createWriteStream('file.text')\\nreable.pipe(writable)\\n\")])])]),r(\"p\",[e._v(\"可以在单个可读流上绑定多个可写流\")]),e._v(\" \"),r(\"p\",[e._v(\"readable.pipe() 会返回目标流的引用(注意是目标流的引用)，这样就可以对流进行链式地管道操作:\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const fs = require('fs');\\nconst r = fs.createReadStream('file.txt');\\nconst z = zlib.createGzip();\\nconst w = fs.createWriteStream('file.txt.gz');\\nr.pipe(z).pipe(w);\\n\")])])]),r(\"p\",[e._v(\"如果可读流发生错误，目标可写流不会自动关闭，需要手动关闭所有流以避免内存泄漏。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"readable-readablelength\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-readablelength\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.readableLength\")]),e._v(\" \"),r(\"p\",[e._v(\"返回队列中准备读取的字节数\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"readable-resume\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-resume\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.resume()\")]),e._v(\" \"),r(\"p\",[e._v(\"返回 this\\n将被暂停的流恢复流动，触发'data'事件\")]),e._v(\" \"),r(\"p\",[e._v(\"readable.resume() 使用场景 可以用来充分消耗流中的数据，但无需处理任何数据\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"getReadableStreamSomehow()\\n  .resume()\\n  .on('end', () => {\\n    console.log('到达流的尽头，但无需读取任何数据');\\n  });\\n\")])])]),r(\"h3\",{attrs:{id:\"readable-setencoding\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-setencoding\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.setEncoding\")]),e._v(\" \"),r(\"p\",[e._v(\"为从可读流读取的数据设置字符编码\")]),e._v(\" \"),r(\"p\",[e._v(\"默认情况下没有字符编码，流返回的是Buffer对象。如果设置了字符编码，则流数据返回自定编码的字符串。例如，调用readable.setEconding('utf-8')会将数据解析为UTF-8数据，返回字符串，调用readable.setEconding('hex')则会将数据编码成十六进制字符串。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const readable = getReadableStreamSomehow()\\nreadable.setEconding('UTF-8')\\nreadable.on('data',(chunk)=>{\\n  assert.equal(typeof chunk ,'string')\\n  console.log('读取到**个字符的字符串数据'，chunk.length)\\n})\\n\")])])]),r(\"h3\",{attrs:{id:\"readable-unpipe\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-unpipe\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.unpipe\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"destination 要移除管道的可写流\")])]),e._v(\" \"),r(\"p\",[e._v(\"解除之前使用pipe绑定的可写流\\n如果没有指定destination 则解绑所有通道\\n如果指定了destination 但它没有建立通道，那么不起任何作用\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const fs = require('fs')\\nconst readable = getReadableStreamSomehow()\\nconst writeable = fsl.createWriteStream('flie.text')\\nreadable.pipe(writeable)\\nsetTimeOut(()=>{\\n  console.log('停止写入 file.text')\\n  readable.unpipe(writeable)\\n  console.log('手动关闭文件流')\\n  readable.end()\\n},1000)\\n\")])])]),r(\"h3\",{attrs:{id:\"readable-unshift\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#readable-unshift\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" readable.unshift\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"chunk 要推回可读队列的数据块。对于非对象模式的流，chunk必须是字符串，Buffer或者uint8Array。对于对象模式的流，chunk可以是任何值，除了null\\n作用:\")])]),e._v(\" \"),r(\"p\",[e._v(\"将数据块推回内部缓冲。可用于以下情景:正被消费中的流需要将一些已经被拉出的数据重置为未消费状态，以便这些数据传送给其他方。\")]),e._v(\" \"),r(\"p\",[e._v(\"触发'end'事件或抛出运行错误后，不能再雕鹰readable.unshift()\")]),e._v(\" \"),r(\"p\",[e._v(\"使用stream.unshift()的开发者可以烤炉切换到transform流。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"双工流或者转换流\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双工流或者转换流\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 双工流或者转换流\")]),e._v(\" \"),r(\"p\",[e._v(\"双工流 同时实现了Readable和writeable的接口的流 也称Duplex流\")]),e._v(\" \"),r(\"p\",[e._v(\"Duplex流的例子包括\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"TCP socket\")]),e._v(\" \"),r(\"li\",[e._v(\"zlib 流\")]),e._v(\" \"),r(\"li\",[e._v(\"crypto 流\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"stream-transform-类\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stream-transform-类\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Stream.transform 类\")]),e._v(\" \"),r(\"p\",[e._v(\"转换流 也是双工流的一种，但它的输入和输出是相关联的。与双工流一样 transform流也同样实现了Readable和writeable的接口\")]),e._v(\" \"),r(\"p\",[e._v(\"transform流的例子包括\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"zlib 流\")]),e._v(\" \"),r(\"li\",[e._v(\"crypto 流\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"transform-destory\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#transform-destory\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" transform.destory\")]),e._v(\" \"),r(\"p\",[e._v(\"销毁流，并触发'error'事件。调用该方法后transform流会释放全部内部资源。实现者不要重写该方法，而应该实现readable_destroy().Transform流的_destroy()方法的默认实现会触发'close'事件。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"stream-finished-stream-callback\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stream-finished-stream-callback\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" stream.finished(stream ,callback)\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"stream 可写流或者可读流\")]),e._v(\" \"),r(\"li\",[e._v(\"callback 通知回调函数\\n当流不再可读，可写、发生错误、或提前关闭，通过该函数获得通知\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const { finished } = require('stream');\\n\\nconst rs = fs.createReadStream('archive.tar');\\n\\nfinished(rs, (err) => {\\n  if (err) {\\n    console.error('流发生错误', err);\\n  } else {\\n    console.log('流已读取完');\\n  }\\n});\\n\\nrs.resume(); // 开始读取流。\\n\")])])]),r(\"p\",[e._v(\"主要用于处理流被提前销毁(如http请求被中止)等异常情况，此时流不会触发'end'或'finish'事件。\")]),e._v(\" \"),r(\"p\",[e._v(\"finished接口也可以promise化\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const finished = util.promisify(stream.finished);\\n\\nconst rs = fs.createReadStream('archive.tar');\\n\\nasync function run() {\\n  await finished(rs);\\n  console.log('流已读取完');\\n}\\n\\nrun().catch(console.error);\\nrs.resume(); // 开始读取流\\n\")])])]),r(\"h2\",{attrs:{id:\"stream-pipeline-stream-callback\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stream-pipeline-stream-callback\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" stream.pipeline(...stream[,callback])\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"...stream 要用管道连接的二个或者多个流\")]),e._v(\" \"),r(\"li\",[e._v(\"callback 通知回调函数\")])]),e._v(\" \"),r(\"p\",[e._v(\"使用管道连接多个流，并传递错误与完成清理工作，当管道连接完成时通知回调函数\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const { pipeline } = require('stream');\\nconst fs = require('fs');\\nconst zlib = require('zlib');\\n\\n// 使用 pipeline 接口连接多个流，并在管道连接完成时获得通知。\\n// 使用 pipeline 可以高效地压缩一个可能很大的 tar 文件：\\n\\npipeline(\\n  fs.createReadStream('archive.tar'),\\n  zlib.createGzip(),\\n  fs.createWriteStream('archive.tar.gz'),\\n  (err) => {\\n    if (err) {\\n      console.error('管道连接失败', err);\\n    } else {\\n      console.log('管道连接成功');\\n    }\\n  }\\n);\\n\")])])]),r(\"p\",[e._v(\"pipeline 接口也可以Promise化:\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"const pipeline = util.promisify(stream.pipeline);\\n\\nasync function run() {\\n  await pipeline(\\n    fs.createReadStream('archive.tar'),\\n    zlib.createGzip(),\\n    fs.createWriteStream('archive.tar.gz')\\n  );\\n  console.log('管道连接成功');\\n}\\n\\nrun().catch(console.error);\\n\")])])])])}],!1,null,null,null);a.default=s.exports}}]);","extractedComments":[]}
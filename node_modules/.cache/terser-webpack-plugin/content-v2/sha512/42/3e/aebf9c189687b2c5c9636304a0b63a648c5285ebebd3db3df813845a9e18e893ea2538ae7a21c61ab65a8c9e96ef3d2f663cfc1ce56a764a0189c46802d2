{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{170:function(e,t,a){\"use strict\";a.r(t);var n=a(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"div\",{staticClass:\"content\"},[a(\"h1\",{attrs:{id:\"组件化\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件化\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 组件化\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[e._v(\"组件化的Vue实例data必须是一个函数\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"在组件上使用v-model\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"解析DOM模板时的注意事项\")])])]),e._v(\" \"),a(\"p\",[e._v(\"有些HTML元素,诸如\"),a(\"code\",[e._v(\"<ul> <ol> <table>\")]),e._v(\"和\"),a(\"code\",[e._v(\"<select>\")]),e._v(\",对于哪些元素可以出现在其内部是有严格限制的.诸如\"),a(\"code\",[e._v(\"<li> <tr>\")]),e._v(\"和\"),a(\"code\",[e._v(\"<option>\")]),e._v(\",只能出现在其他某些特定的元素内部.\")]),e._v(\" \"),a(\"p\",[e._v(\"这会导致我们使用这些有约束的条件的元素时遇到一些问题.例如:\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"<table>\\n  <blog-post-row></blog-post-row>\\n</table>\\n\")])])]),a(\"p\",[e._v(\"这个自定义组件\"),a(\"code\",[e._v(\"<blog-post-row>\")]),e._v(\"会被作为无效的内容提升到外部,并导致最终渲染结果出错.幸好这个特殊的is特性给了我们一个变通的办法\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('<table>\\n  <tr is=\"blog-post-row\">\\n</table>\\n')])])]),a(\"h2\",{attrs:{id:\"组件注册的方式\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件注册的方式\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 组件注册的方式\")]),e._v(\" \"),a(\"p\",[e._v(\"1.全局注册组件\")]),e._v(\" \"),a(\"p\",[e._v(\"组件化是Vue另一个重要的概念,因为它是一种抽象,允许我们使用小型,独立和通常可复用的组件构建大型应用.\")]),e._v(\" \"),a(\"p\",[e._v(\"全局组件注册的方式:\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"首先注册一个组件\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"Vue.component('todo-item',{\\n  template:'<li>这是一个代办项</li>', //模板\\n  props:[],\\n  data(){\\n    return {\\n      message:'' //保存父组件传递过来的参数,一般需要动态绑定\\n    }\\n  }\\n})\\n\")])])]),a(\"ul\",[a(\"li\",[e._v(\"在别的组件当中使用(全局注册的组件可以在任意的组件当中使用)\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('<div id=\"app-7\">\\n  <ol>\\n    <todo-item\\n      v-for=\"item in groceryList\" //最好带上key以用来给每个被循环渲染出来的元素打上一个特定的标签,防止在删除DOM时出错\\n      v-bind:todo=\"item\"\\n      v-bind:key=\"item.id\">\\n    </todo-item>\\n  </ol>\\n</div>\\n')])])]),a(\"p\",[e._v(\"2.局部注册组件\")]),e._v(\" \"),a(\"p\",[e._v(\"全局注册的组件是不够理想的.比如,如果你使用一个像webpack这样的构建系统,全局注册所有的组件意味着即便你已经不再使用一个组件了,它任然会包含在你最终的构建结果当中.这造成了用户下载的JacScript的无意义的增加.\")]),e._v(\" \"),a(\"p\",[e._v(\"在这些情况下,我们可以通过一个普通的JavaScript对象来定义组件\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var ComponentA = { /* ... */ }\\nvar ComponentB = { /* ... */ }\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    'component-a': ComponentA,\\n    'component-b': ComponentB\\n  }\\n})\\n\")])])]),a(\"h2\",{attrs:{id:\"动态渲染组件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#动态渲染组件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 动态渲染组件\")]),e._v(\" \"),a(\"p\",[e._v(\"有时候我们可能需要在不同的组件之间进行动态的切换\")]),e._v(\" \"),a(\"p\",[e._v(\"那么我们需要使用Vue的一个\"),a(\"code\",[e._v(\"<component>\")]),e._v(\"元素加一个特殊的is特性来实现\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('\\x3c!-- 组件会在 `currentTabComponent` 改变时改变 --\\x3e\\n<component v-bind:is=\"currentTabComponent\"></component>\\n')])])]),a(\"p\",[e._v(\"在上述示例中，currentTabComponent 可以包括 (指的就是一个组件)\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"已注册组件的名字\")]),e._v(\" \"),a(\"li\",[e._v(\"一个组件的选项对象\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"在动态组件上使用-keep-alive\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在动态组件上使用-keep-alive\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 在动态组件上使用 keep-alive\")]),e._v(\" \"),a(\"p\",[e._v(\"当我们切换组件的时候,我们可能会项保存组件之前的状态,但是我们切换组件之后组件都会被重现渲染之前的状态会被清空,这是会我们只需要在组件外面包一层\"),a(\"code\",[e._v(\"<keep-alive>\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('\\x3c!-- 失活的组件将会被缓存！--\\x3e\\n<keep-alive>\\n  <component v-bind:is=\"currentTabComponent\"></component>\\n</keep-alive>\\n')])])])])}],!1,null,null,null);s.options.__file=\"two.md\";t.default=s.exports}}]);","extractedComments":[]}
{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{191:function(e,a,t){\"use strict\";t.r(a);var l=t(0),r=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t(\"div\",{staticClass:\"content\"},[t(\"h1\",{attrs:{id:\"babel\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#babel\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" babel\")]),e._v(\" \"),t(\"p\",[e._v(\"babel是一个javaScript的编译器\")]),e._v(\" \"),t(\"p\",[e._v(\"主要用于在旧版浏览器或环境中将ES6代码转换成向后兼容的JavaScript版本.\")]),e._v(\" \"),t(\"p\",[e._v(\"babel默认只转换新的JavaScript句法,而不转换新的API,比如Iterator Generator Set Map proxy\\nReflect Symbol Promise等全局对象,以及一些定义在全局对象上的方法(比如Object.assign)都不会转码.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"介绍\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#介绍\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 介绍\")]),e._v(\" \"),t(\"p\",[e._v(\"babel是一个编译器.编译代码的过程分为三个阶段:解析 转换 生成\")]),e._v(\" \"),t(\"p\",[e._v(\"解析时babel不执行任何的操作,只是生成一分相同的额代码,我们需要为babel添加一些插件来做一些事情.\")]),e._v(\" \"),t(\"p\",[e._v(\"对于babel的编译过程,解析是基础,所有语法的转换过程全部由插件完成,不同的插件负责不同的语法转换,将一堆插件组合在了一起就成了预设.\")]),e._v(\" \"),t(\"p\",[e._v(\"其中官方给出的插件组合以及预设有:\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"env\")]),e._v(\" \"),t(\"li\",[e._v(\"es2015\")]),e._v(\" \"),t(\"li\",[e._v(\"es2016\")]),e._v(\" \"),t(\"li\",[e._v(\"es2017\")]),e._v(\" \"),t(\"li\",[e._v(\"lastet\")]),e._v(\" \"),t(\"li\",[e._v(\"stage-0\")]),e._v(\" \"),t(\"li\",[e._v(\"stage-1\")]),e._v(\" \"),t(\"li\",[e._v(\"stage-2\")]),e._v(\" \"),t(\"li\",[e._v(\"stage-3\")]),e._v(\" \"),t(\"li\",[e._v(\"flow\")]),e._v(\" \"),t(\"li\",[e._v(\"react\")]),e._v(\" \"),t(\"li\",[e._v(\"minify\")])]),e._v(\" \"),t(\"p\",[e._v(\"其中预设babel-preset-env等同于babel-preset-lastet或babel-preset-es2015 + babel-preset-es2016 + babel-preset-es2017.对于一些老项目可能还在使用babel-preset-es2015建议使用babel-preset-env来替换掉.\")]),e._v(\" \"),t(\"p\",[e._v(\"最常见的预设配置为\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"{\\n    preset:['env','stage-3']\\n}\\n\")])])]),t(\"h2\",{attrs:{id:\"polyfill\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#polyfill\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" polyfill\")]),e._v(\" \"),t(\"p\",[e._v(\"为什么使用了babel还要使用ployfill?\")]),e._v(\" \"),t(\"p\",[e._v(\"因为babel是基于ES5来转换ES6的语法,如果一些浏览器或者环境对ES5的支持程度也比较低的话那么就必须使用ployfill来支持低版本的浏览器\")]),e._v(\" \"),t(\"p\",[e._v(\"Babel作为编译器,只对语法部分转换\")]),e._v(\" \"),t(\"p\",[e._v(\"如:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"[1,2,3].map(n=>n+1)\\n\")])])]),t(\"p\",[e._v(\"转换后\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"[1,2,3].map(function(n){\\n    return n+1\\n})\\n\")])])]),t(\"p\",[e._v(\"上面代码只是转换了箭头函数语法,但是对数组的新原生方法map没有进行转换\")]),e._v(\" \"),t(\"p\",[e._v(\"为了支持新的原生对象和方法,需要使用babel-polyfill.就像plugins一样也可以或者选择性地包含所需要的内容.\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原理\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 原理\")]),e._v(\" \"),t(\"p\",[e._v(\"当运行环境中并没有实现的一些方法,babel-polyfill会给其做兼容.但是这样做也有一个缺点,就是会污染全局变量,并且项目打包后体积会增大很多,因为把整个依赖包也搭进去了\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"用法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#用法\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 用法\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"1. npm install --save babel-polyfill\\n2. 在应用的入口引用,以确保它能够最先加载\\n   import \\\"babel-polyfill\\\" \\n   或者`require('babel-polyfill')`\\n\")])])]),t(\"h3\",{attrs:{id:\"es5\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es5\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" ES5\")]),e._v(\" \"),t(\"p\",[e._v(\"由于babel假定代码是在ES5环境中运行的,因此他会使用ES5函数.如果你当前使用的环境不知此ES5或者只支持部分的ES5那么需要使用polyfill来增加这些方法的支持.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"babel-runtime\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#babel-runtime\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" babel-runtime\")]),e._v(\" \"),t(\"p\",[e._v(\"babel-ployfill会污染全局对象和内置对象的原型,为了不污染全局对象和内置对象的原型,但是又想使用新鲜的语法.\\n那么我们可以配合使用babel-runtime和babel-plugin-transform-runtime.\\n比如当前运行环境不支持promise,可以通过引入babel-runtime/core-js/promise来获取promise,\\n或者通过babel-plugin-transform-runtime自动重写promise. 一般都是使用自动重写promise.\")]),e._v(\" \"),t(\"p\",[e._v(\"也许有人会奇怪，为什么会有两个runtime插件，其实是有历史原因的：\\n刚开始开始只有babel-runtime插件，但是用起来很不方便，在代码中直接引入helper 函数，意味着不能共享，造成最终打包出来的文件里有很多重复的helper代码。\\n所以，Babel又开发了babel-plugin-transform-runtime，这个模块会将我们的代码重写，如将Promise重写成_Promise（只是打比方），然后引入_Promise helper函数。\\n这样就避免了重复打包代码和手动引入模块的痛苦。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"用法-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#用法-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 用法\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"1.npm i -S babel-runtime\\n2.npm i -S babel-plugin-transform-runtime\\n3.写入`.babelrc`\\n\")])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('{\\n    \"plugin\":[\"transform-runtime\"]\\n}\\n')])])]),t(\"h3\",{attrs:{id:\"不足\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#不足\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 不足\")]),e._v(\" \"),t(\"p\",[e._v(\"babel-runtime 不能转换代码的实力方法,比如这样的代码\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"'!!!'.repeat(3);\\n'hello'.inculdes('h')\\n\")])])]),t(\"p\",[e._v(\"这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。\")])])}],!1,null,null,null);a.default=r.exports}}]);","extractedComments":[]}
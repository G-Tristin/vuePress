{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{220:function(r,s,e){\"use strict\";e.r(s);var a=e(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var r=this,s=r.$createElement,e=r._self._c||s;return e(\"div\",{staticClass:\"content\"},[e(\"h1\",{attrs:{id:\"css\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#css\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" css\")]),r._v(\" \"),e(\"p\",[r._v(\"这里是一块记录我遇到的一些CSS的问题的解决方式，以及一些SASS的学习记录。\")]),r._v(\" \"),e(\"h2\",{attrs:{id:\"sass混合\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sass混合\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" SASS混合\")]),r._v(\" \"),e(\"p\",[r._v(\"混合器在某些方面和类很相似。都让我们给一大段样式命名，所以当我们选择使用哪一个是会让我们产生困惑。其实最重要的区别就是类名是在html文件中的引用，而混合器\\n则是在样式表中应用。这就意味者类名具有语义化的含义，而不仅仅是一种展示性的描述：用来描述html元素的含义而不是html的外观。而另一方面，混合器是展示性的描述，用来描述一条CSS应用之后会产生什么样的效果。\")]),r._v(\" \"),e(\"p\",[r._v(\"一般 类名 都需要具有语义化含义，而不仅仅是一种展示性的描述：用来描述html元素的含义而不是html元素的外观。---这就是类名的命名方式\")]),r._v(\" \"),e(\"p\",[r._v(\"一般 混合器 是展示性的 它描述了包含它的CSS规则最终的视觉样式：用来描述展示样式的名臣。 ---这是混合器的命名方式\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"混合器中的css规则\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#混合器中的css规则\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 混合器中的CSS规则\")]),r._v(\" \"),e(\"p\",[r._v(\"混合器中不仅可以包含属性，还可以包含css规则，即包含选择器和选择器中的属性：\")]),r._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[r._v(\"@mixin no-bullets{\\n  list-style:none;\\n  li{\\n    list-style-image:none;\\n    list-style-type:none;\\n    margin-left:0px;\\n  }\\n}\\n\\n.plain{\\n  color:red;\\n  @include no-bullets;\\n}\\n\\n编译结果\\n.plain{\\n  color:red;\\n  list-style:none;\\n}\\n.plain li{\\n  list-style-image:none;\\n  list-style-type:none;\\n  margin-left:0px;\\n}\\n\")])])]),e(\"h3\",{attrs:{id:\"给混合器传参\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#给混合器传参\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 给混合器传参\")]),r._v(\" \"),e(\"p\",[r._v(\"混合器并不一定要生成同样的样式。可以通过在@include混合器是给混合器传参，来定制混合器生成的精准样式。当@include混合器时，参数其实就是可以赋值给CSS的变量。\")]),r._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[r._v(\"定义:\\n@mixin link-color($normal,$hover,$visited){\\n  color:$normal;\\n  &:hover{\\n    color:$hover;\\n  }\\n  &:visited{\\n    color:$visited;\\n  }\\n}\\n\\n引入:\\na{\\n  @include link-color(blue,red,black);\\n}\\n\\n编译结果:\\na{\\n  color:blue;\\n}\\na:hover{\\n  color:red;\\n}\\na:visited{\\n  color:black;\\n}\\n由于传递参数的时候很难区分每个参数时什么意思，参数之间是一个什么样的顺序。为了解决这个问题sass允许通过语法$name:value的形式指定每一个参数的值。\\n这种传参的形式，参数顺序就不需要在乎了，只需要保证没有漏掉的参数就行了。\\na{\\n  @include link-color($normal:blue,$hover:red,$visited:black);\\n}\\n\")])])]),e(\"h3\",{attrs:{id:\"混合器的参数默认值\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#混合器的参数默认值\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 混合器的参数默认值\")]),r._v(\" \"),e(\"p\",[r._v(\"为了在@include混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用$name:default-value的声明形式。\\n默认值可以是任何有效的css属性，甚至是其他参数的引用，代码如下：\")]),r._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[r._v(\"@mixin link-colors($nomal,$hover:$noaml,$visited:$normal){\\n  color:$normal;\\n  &:hover{\\n    color:$hover;\\n  }\\n  &:visited{\\n    color:$visited;\\n  }\\n}\\n\")])])]),e(\"p\",[r._v(\"如果像下面这样调用\")]),r._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[r._v(\"a{\\n  @include link-colors(red);\\n}\\n\")])])]),e(\"p\",[r._v(\"那么$hover以及$visited也都会被赋值成为red\")]),r._v(\" \"),e(\"h2\",{attrs:{id:\"使用选择器继承来精简sass\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用选择器继承来精简sass\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 使用选择器继承来精简SASS\")]),r._v(\" \"),e(\"p\",[r._v(\"使用SASS的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承就是一个选择器可以继承另一个选择器的所有\\n样式。这个通过@extend语法来实现。\")]),r._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[r._v(\".error{\\n  border:1px solid red;\\n  background-color:#fdd;\\n}\\n.seriousError{\\n  @extend .error;\\n  border-width:3px;\\n}\\n\")])])]),e(\"p\",[r._v('在上面的代码中,.seriousError将会继承样式表中任何位置处类名为.error定义的所有样式。以class=\"seriousError\"修饰的html元素最终展示效果就好像是\\nclass=\"seriousError error\"。相关元素不仅会拥有一个3px宽的边框，而且这个边框将会变成红色的并且有一个浅红色的背景。这些都是在.error当中定义的。\\n.seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承。')]),r._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[r._v(\".error a{\\n  color:red;\\n  font-weight:100;\\n}\\n\")])])]),e(\"p\",[r._v(\"上面这段代码也会被继承 并且应用到.seriousError a的html元素上 单不是应用到.seriousError的html元素上\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"何时使用继承\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#何时使用继承\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 何时使用继承\")]),r._v(\" \"),e(\"p\",[r._v(\"混合器主要用于展示性样式的重用，而类名主要用于语义化样式的重用。因为继承是基于类的(有时是基于其他类型的选择器)，所以继承应该是建立在语义化的关系上的。\\n当一个元素拥有类(.seriousError)表明它属于另一个类(.error)这时候就可以使用继承。\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"继承的高级用法\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承的高级用法\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 继承的高级用法\")]),r._v(\" \"),e(\"p\",[r._v(\"任何CSS规则都可以继承其他规则，几乎任何css规则也都可以被继承。大多数情况下你可能只想对类实现继承，但是有些场合你可能想做的更多。最常用的一个高级用法是\\n继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为他们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承。\")]),r._v(\" \"),e(\"p\",[r._v(\"如果一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式\")]),r._v(\" \"),e(\"p\",[r._v(\"如果一个选择器序列继承另一个选择器，那么只有完全匹配这个选择器的元素才会继承另一个选择器的样式\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"继承的工作细节\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承的工作细节\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 继承的工作细节\")]),r._v(\" \"),e(\"p\",[r._v(\"跟变量和混合不同，继承不仅仅用css样式替换某一处的代码那么简单。为了不让你对继承产生疑惑，对这背后的工作原理有一定的了解是非常重要的。\")]),r._v(\" \"),e(\"p\",[r._v(\"@extend背后最基本的想法是，如果\"),e(\"code\",[r._v(\".seriousError @extend .error\")]),r._v(\",那么样式表中的任何一处的.seriousError都用\"),e(\"code\",[r._v(\".error .seriousError\")]),r._v(\"这一组选择器进行替换.\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"继承的最佳实践\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承的最佳实践\",\"aria-hidden\":\"true\"}},[r._v(\"#\")]),r._v(\" 继承的最佳实践\")]),r._v(\" \"),e(\"p\",[r._v(\"通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。但是如果你不小心，可能会让生成的css中包含大量的选择器复制。\\n避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。如果你这么做，同时被继承的css规则有通过后代选择器修饰的样式，生成css中的选择器的数量很快就会失控：\\n值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。\")])])}],!1,null,null,null);s.default=n.exports}}]);","extractedComments":[]}
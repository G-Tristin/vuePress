{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{172:function(e,t,n){\"use strict\";n.r(t);var a=n(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{staticClass:\"content\"},[n(\"h1\",{attrs:{id:\"ts类型\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ts类型\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" ts类型\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"元组-tuple\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#元组-tuple\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 元组 Tuple\")]),e._v(\" \"),n(\"p\",[e._v(\"在TS当中数组合并了相同类型的对象，而元组则是合并了不同类型的对象。\")]),e._v(\" \"),n(\"p\",[e._v(\"元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为Sting和Number类型的元组\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"let x:[number,string] = [3,'4']\\n在此例当中 我们定义了 x 为元组，它的值是[3,'4']。它的类型校验是[number,string]。\\n\")])])]),n(\"p\",[e._v(\"当访问一个越界的元素，它的类型会被限制为元组中每个类型的联合类型\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型\\nconsole.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString\\nx[6] = true; // Error, 布尔不是(string | number)类型\\n\")])])]),n(\"h3\",{attrs:{id:\"枚举\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#枚举\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 枚举\")]),e._v(\" \"),n(\"p\",[e._v(\"枚举类型是对JavaScript标准类型的一个补充。向C等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字。\")]),e._v(\" \"),n(\"p\",[e._v(\"枚举类型通过\"),n(\"code\",[e._v(\"enum\")]),e._v(\"关键字来定义\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"enum Days { Sum, Mon, Tue, Wed, Thu, Fri, Sat }\\n\")])])]),n(\"p\",[e._v(\"枚举成员会被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\\n\\nconsole.log(Days[\"Sun\"] === 0); // true\\nconsole.log(Days[\"Mon\"] === 1); // true\\nconsole.log(Days[\"Tue\"] === 2); // true\\nconsole.log(Days[\"Sat\"] === 6); // true\\n\\nconsole.log(Days[0] === \"Sun\"); // true\\nconsole.log(Days[1] === \"Mon\"); // true\\nconsole.log(Days[2] === \"Tue\"); // true\\nconsole.log(Days[6] === \"Sat\"); // true\\n')])])]),n(\"h4\",{attrs:{id:\"枚举分类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#枚举分类\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 枚举分类\")]),e._v(\" \"),n(\"p\",[e._v(\"1.普通枚举与常数枚举的区别\")]),e._v(\" \"),n(\"p\",[e._v(\"常数枚举会在编译阶段被删除，并且不能包含计算成员。并且常数枚举的声明方式和普通枚举的声明方式也不相同，常数枚举通过 const enum来定义枚举类型\")]),e._v(\" \"),n(\"p\",[e._v(\"2.外部枚举\")]),e._v(\" \"),n(\"p\",[e._v(\"外部枚举是使用declare enum定义的枚举类型\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"voild\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#voild\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" voild\")]),e._v(\" \"),n(\"p\",[e._v(\"voild表示没有任何类型,当一个函数没有返回值的时候，可以将其的返回值类型设置为void\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"function warnUser():vaild{\\n  console.log('This is my warning message')\\n}\\n\")])])]),n(\"h3\",{attrs:{id:\"never\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#never\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" never\")]),e._v(\" \"),n(\"p\",[e._v(\"never类型表示的是那些永远不存在的值的类型。例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或者箭头函数表达式的返回值类型。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"object\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#object\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Object\")]),e._v(\" \"),n(\"p\",[e._v(\"Object 表示非原始类型，也就是除了Number，String,boolean,symbol,null或undefined之外的类型。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"类型断言\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类型断言\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 类型断言\")]),e._v(\" \"),n(\"p\",[e._v(\"有时候你可能会遇到这样的情况，你会比TypeScript更加了解某个值的详细信息。通常这回发生在你清楚的知道一个实体具有比他现有类型更加确切的类型。\")]),e._v(\" \"),n(\"p\",[e._v(\"用法:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，TS会报错\\nfunction getLength(something: string | number): number {\\n    if (something.length) {\\n        return something.length;\\n    } else {\\n        return something.toString().length;\\n    }\\n}\\n当我们访问一个联合类型的变量是，应为变量的类型可能是字符串或者是数字\\n所以使用something.length时TS会报错(数字没有长度属性)。 此时我们可以使用类型断言 断言something就是一个字符串 TS就不会报错了\\nfunction getLength(something: string | number): number {\\n    if ((<string>something).length) {   \\n        return (something as string).length;\\n    } else {\\n        return something.toString().length;\\n    }\\n}\\n\")])])])])}],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}
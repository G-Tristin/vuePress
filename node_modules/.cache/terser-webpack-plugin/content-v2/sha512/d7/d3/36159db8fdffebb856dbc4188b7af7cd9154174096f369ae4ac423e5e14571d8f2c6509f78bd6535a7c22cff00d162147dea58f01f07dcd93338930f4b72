{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{201:function(e,n,t){\"use strict\";t.r(n);var a=t(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"div\",{staticClass:\"content\"},[t(\"h2\",{attrs:{id:\"在typescript当中使用npm包\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在typescript当中使用npm包\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 在typescript当中使用npm包\")]),e._v(\" \"),t(\"p\",[e._v(\"一般我们通过 import foo from 'foo' 导入一个npm包，这是符合ES6规范的。\")]),e._v(\" \"),t(\"p\",[e._v(\"在我们尝试给一个npm包创建声明文件的之前，需要看看它的申明文件是否存在。一般来说，npm包的声明文件就存在2个地方。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[e._v(\"与改npm包绑定在一起。判断依据是package.json种有types字段，或者拥有一个index.d.ts声明文件。这种模式不需要额外的安装其它包，是\\n最为推荐的，所以以后我们自己要创建npm包的时候，最好也将申明声明文件和npm包绑定在一起。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"发布到@types里。我们只需要尝试安装一下对应的@types包就知道是否存在该声明文件，安装命令是 npm install @types/foo --save-dev。这种模式\\n一般是由于npm包的维护者没有提供声明文件，所以只能由他人来将声明文件发布到@types里了\")])])]),e._v(\" \"),t(\"p\",[e._v(\"假如以上两种方式都没有找到对应的文件，那么我们就需要自己为它书写声明文件了。由于是通过import语句导入的模块，所以声明文件存放的位置也有所束缚，\\n一般有2种方案。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[e._v(\"创建一个node_modules/@types/foo/index.d.ts文件，存放foo模块的文件。这种方式不需要二外的配置，但是node_modules目录不稳定，代码也没有保存到仓库当中，无法回溯版本，有者不小心被删除的风险，故不太建议使用这种方案，一般只是用作临时测试。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"创建一个types目录，专门用来管理自己写的申明文件，将foo的声明文件放到types/foo/index.d.ts中。这种方式需要配置下tsconfig.json中的path和baseUrl字段。\")])])]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('tsconfig的内容\\n{\\n    \"compilerOptions\": {\\n        \"module\": \"commonjs\",\\n        \"baseUrl\": \"./\",\\n        \"paths\": {\\n            \"*\": [\"types/*\"]\\n        }\\n    }\\n}\\n')])])]),t(\"p\",[e._v(\"如此配置之后，拖过import导入foo的时候，也会去types目录下寻找对应的模块声明文件了。\")]),e._v(\" \"),t(\"p\",[e._v(\"注意module配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了commonjs这个最常用的选项，后面的教程也都默认选用这个选项。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"npm-包的声明文件和全局变量的申明文件存在很大的区别。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#npm-包的声明文件和全局变量的申明文件存在很大的区别。\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" npm 包的声明文件和全局变量的申明文件存在很大的区别。\")]),e._v(\" \"),t(\"p\",[e._v(\"在npm包的声明文件中，使用declare不会再声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件当中使用export导出，然后在使用方inport导入后，才会应用到这些类型声明。\")]),e._v(\" \"),t(\"p\",[e._v(\"npm包的声明文件主要有一下几种语法:\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"export 导出变量\")]),e._v(\" \"),t(\"li\",[e._v(\"export namespace 导出(含有子属性的)对象\")]),e._v(\" \"),t(\"li\",[e._v(\"export default ES6默认导出\")]),e._v(\" \"),t(\"li\",[e._v(\"export= commonjs 导出模块\")])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"export-的语法和普通的js中的语法类似，区别仅在于声明文件中禁止定义具体的实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#export-的语法和普通的js中的语法类似，区别仅在于声明文件中禁止定义具体的实现\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" export 的语法和普通的js中的语法类似，区别仅在于声明文件中禁止定义具体的实现\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"export const name:string\\nexport function getname():string\\nexport class Animal {\\n    constructor(name: string);\\n    sayHi(): string;\\n}\\nexport enum Directions {\\n    Up,\\n    Down,\\n    Left,\\n    Right\\n}\\n\\n// 注意以下是导出声明类型\\nexport interface Options {\\n    data: any;\\n}\\n\")])])]),t(\"p\",[e._v(\"对应的导入和使用模块应该是这样:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// src/index.ts\\nimport { name, getName, Animal, Directions, Options } from 'foo';\\nconsole.log(name);\\nlet myName = getName();\\nlet cat = new Animal('Tom');\\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\\nlet options: Options = {\\n    data: {\\n        name: 'foo'\\n    }\\n};\\n\")])])]),t(\"h4\",{attrs:{id:\"混用declare和export\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#混用declare和export\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 混用declare和export\")]),e._v(\" \"),t(\"p\",[e._v(\"我们也可以使用decalre先声明多个变量，最后再一次性导出。上文的声明文件可以等价的改写为:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// types/foo/index.d.ts\\n\\ndeclare const name:string\\ndeclare function getName():string\\ndeclare class Animal{\\n  constructor(name:string)\\n  sayHi():sting\\n}\\n\\ndeclare enum Directions{\\n  up,\\n  Down,\\n  Left,\\n  Right\\n}\\n\\ninterface Options{\\n  data:any\\n}\\n\\nexport(name,getName,Animal,Directions,Options)\\n\")])])]),t(\"p\",[e._v(\"注意与全局变量的声明文件类似，interface 前提不需要declare的。\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"export-namespace\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#export-namespace\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" export namespace\")]),e._v(\" \"),t(\"p\",[e._v(\"与declare namespace类似，export namespace用来导出一个拥有子属性的对象\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// type/foo/index.d.ts\\n\\nexport namespace foo{\\n  const name:string\\n  namespace bar {\\n    function baz():string;\\n  }\\n}\\n\\n// src/index.ts\\nimpor {foo} from 'foo';\\nconsole.log(foo.name);\\nfoo.bar.baz();\\n\")])])]),t(\"h5\",{attrs:{id:\"declare-namespace-与-export-namespace-以及-interface的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#declare-namespace-与-export-namespace-以及-interface的区别\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" declare namespace 与 export namespace 以及 interface的区别\")]),e._v(\" \"),t(\"p\",[e._v(\"declare namespae 在全局的声明文件中 声明一个全局的 拥有子对象的变量对象\")]),e._v(\" \"),t(\"p\",[e._v(\"export namespace 导出一个拥有子对象的变量对象\")]),e._v(\" \"),t(\"p\",[e._v(\"interface 声明一个接口 这个接口一般用来描述对象\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"export-default\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#export-default\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" export default\")]),e._v(\" \"),t(\"p\",[e._v(\"导出默认模块 但是只有function class和interface可以默认导出\")])])}],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}